# 23장 실행 컨텍스트

## 소스코드의 타입

각각의 타입에 맞는 스코프와 실행 컨텍스트를 생성하고 실행에 활용한다.

- 전역
- 함수
- eval
- 모듈

## 소스코드 평가 & 실행

#### 소스코드 평가

- 실행 컨텍스트 생성
- 선언문 실행 (변수, 함수 등)
- 생성된 변수, 함수 식별자를 키로 스코프에 등록

#### 소스코드 실행

- 선언문을 제외한 소스코드가 순차적으로 실행 (런타임 시작)
- 실행에 필요한 정보는 실행 컨텍스트가 관리하는 스코프에서 검색
- 실행 결과는 다시 스코프에 등록

## 실행 컨텍스트의 역할

실행 컨텍스트는 소스 코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 관리한다.

- 식별자를 등록, 관리하는 스코프
- 코드 실행 순서 관리를 구현한 내부 메커니즘

으로 구성되어 있고 모든 코드의 실행을 관리한다.

- 식별자, 스코프 -> 실행 컨텍스트의 렉시컬 환경으로 관리
- 코드 실행 순서 -> 실행 컨텍스으 스택으로 관리

## 실행 컨텍스트 스택 (콜 스택)

JS 엔진은 전역 실행 컨텍스트와 함수 실행 컨텍스트를 생성한다. 생성된 실행 컨텍스트는 스택 자료구조로 관리되며 이것을 실행 컨텍스트 스택(콜 스택)이라고 부른다.

실행 컨텍스트 스택은 코드의 실행 순서를 관리한다. 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트는 현재 실행 중인 코드의 실행 컨텍스트이다.

## 렉시컬 환경

식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조이며, 실행 컨텍스트를 구성하는 컴포넌트이다.

## 실행 컨텍스트 생성 & 식별자 검색

책의 그림을 꼭 참조할것.

#### 전역 환경 레코드

- 전역 스코프 역할의 "전역 환경 레코드"는 "객체 환경 레코드"와 "선언적 환경 레코드"로 구성된다.
- 객체 환경 레코드 -> var 키워드로 선언한 전역 변수, 함수 선언문으로 정의한 전역 함수, 빌트인 전역 프로퍼티와 빌트인 전역 함수, 표준 빌트인 객체를 관리한다.
- 선언적 환경 레코드 -> let, const 키워드로 선언한 전역 변수를 관리한다.

#### 객체 환경 레코드

- 객체 환경 레코드는 BindingObject객체와 연결된다.
- BindingObject -> var 키워드로 선언한 전역 변수, 함수 선언문로 정의한 전역 함수를 전역 객체 프로퍼티와 메서드로 등록해줌.
- 현재 단계는 코드 평가 단계 이며, 변수 선언문 이전에 선언된 변수를 참조할 수 있으며, 값은 항상 undefined 이다. 이것이 변수 호이스팅의 원인이다.
- 함수의 경우 함수 선언문으로 정의된 함수가 평가되면 동일한 이름의 식별자가 BindingObejct에 등록하고 함수 객체를 즉시 할당한다. 따라서 함수 선언문으로 정의된 함수는 선언문 이전에 호출 가능하다.

#### 선언적 환경 레코드

- let, const로 선언한 전역 변수는 전역 객체의 프로퍼티가 되지 않고 개념적인 블록 내부에 존재한다. 개념적 블록 = 선언적 환경 레코드
- const 변수는 "선언"과 "초기화"가 분리되어서 진행된다. 초기화(변수 선언문 도달) 전까지 "일시적 사각 지대(TDZ)"에 빠진다.
- let, const 변수도 호이스팅이 발생하지만, TDZ에 빠지기 때문에 참조가 불가능하다.(uninitialized 이다.)

#### 함수 환경 레코드

- 함수 실행 컨텍스트 생성 시 렉시컬 환경의 구성요소
- 매개변수, arguments객체, 함수 내부의 지역 변수, 중첩 함수를 등록하고 관리한다.
- 함수 환경 레코드는 전역 환경 레코드처럼 두가지의 환경 레코드로 구분되지 않는다.

## 블록 레벨 스코프

#### 블록 레벨 스코프

- let, const 변수는 코드 블록(함수, if문, for문, while문, try/catch문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.
- 블록 레벨 스코프에서는 선언전 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존 렉시컬 환경과 교체하고 외부 렉시컬 환경에 대한 참조는 블록 스코프가 생성되기 전의 렉시컬 환경을 가리킨다.
- 코드 블록의 실행이 종료되면 코드 블록 실행 이전의 렉시컬 환경으로 돌아간다.

# 24장 클로저

- 클로저는 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성이다.

## 렉시컬 스코프

- JS 엔진은 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다. 이를 렉시컬 스코프라 한다.
- 스코프의 실체는 실행 컨텍스트의 렉시컬 환경이다.
- 스코프 체인은 외부 렉시컬 환경에 대한 참조로 상위 렉시컬 환경과 연결 되는것이다.
- 렉시컬 환경의 "외부 렉시컬 환경에 대한 참조"에 저장할 참조값(상위 스코프에 대한 참조)는 함수의 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다. 이것이 렉시컬 스코프이다.

## 함수 객체의 내부 슬롯 [[Environment]]

- 함수는 자신의 내부 슬롯 [[Environment]] 에 자신이 정의된 환경(상위 스코프의 참조)를 저장한다.
- 함수 객체의 내부 슬롯 [[Environment]] 에 저장된 현재 실행 중인 실행 컨텍스트의 "렉시켤 환경의 참조"가 상위 스코프이다. 호출 시 생성될 함수 렉시컬 환경의 "외부 렉시컬 환경에 대한 참조"로 사용된다.

## 클로저 & 렉시컬 환경

- 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료된 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 한다.
- 외부 함수의 실행이 종료되면 실행 컨텍스트가 스택에서 제거되지만 렉시컬 환경까지 소멸하는 것은 아니다. 참조되고 있으면 gc의 대상이 되지 않는다.

## 클로저 활용

- 클로저는 상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용한다.

# 25장 클래스

## 클래스 호이스팅

- 클래스는 함수로 평가된다.
- 클래스 선언문도 변수, 함수과 마찬가지로 호이스팅이 발생한다. 단, 클래스는 let, const 키워드로 선언한 변수처럼 호이스팅된다. 따라서 TDZ에 빠질 수 있다.

## 클래스

#### constructor

- 인스턴스 생성 & 초기화 하기 위한 매서드.
- 하나만 정의 가능
- return을 생략해야한다. 객체를 반환하면 암묵적인 this 반환이 무시되고 객체가 반환된다.
