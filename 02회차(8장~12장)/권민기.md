# 8, 9, 10, 11, 12

# 08 제어문

조건에 따라 코드 블록을 실행하거나 반복실행 할 때 사용된다.

## 8.1 블록문

: 0개 이상의 문을 중괄호로 묶은 것

```jsx
// 블록문
{
	var foo = 10;
}

// 제어문 
var x = 1;
if (x < 10) { 
	x++;
}

// 함수선언문
function sum(a, b){
	return a + b;
}
```

+) 문의 끝에는 세미콜론을 붙잉는것이 일반적이나 블록문은 자체 종결성을 가지기에 세미콜론을 붙이지 않는다.

## 8.2 조건문

: 주어진 조건식의 평과 결과에 따라 코드 블록의 실행을 결정

### 8.2.1 if else 문

: 조건식의 평과결과(참, 거짓)에 따라 실행할 코드 블록을 결정한다.

조건식은 **불리언 값으로 평가될 수 있는 표현식**이다.

```jsx
if (조건식) {
	// 조건식이 참이면 이 코드 블록이 실행된다.
} else {
	// 조건식이 거짓이면 이 코드 블록이 실행된다.
}
```

대부분의 if else 문은 삼항 조건 연산자로 바꿔 쓸 수 있다.

```jsx
var x = 2;

// if else 문
var result;
if (×%2) {
	result ='홀수';
} else {
	result = ' 짝수';
}

// 삼항연산자
var result = x % 2 ? '홀수' : '짝수';
```

### 8.3.2 switch 문

: 주어진 표현식을 평가하여 값과 일치하는 표현식을 갖는 case문으로 실행 흐름을 옮긴다.

case문은 상황을 의미하는 표현식을 지정하고 콜론으로 마친다.

```jsx
switch (표현식) { 
	case 표현식1:
		// switch 문의 표현식과 표현식1이 일치하면 실행될 문;
		break; 
	case 표현식2:
		// switch 문의 표현식과 표현식2가 일치하면 실행될 문;
		break; 
	default:
		// switch 문의 표현식과 일치하는 case 문이 없을 때 실행될 문;
}
```

+) switch문의 표현식은 불리언 값보다 **문자열이나 숫자 값인 경우가 많다.**

+) break를 작성해주지 않는다면 switch문이 끝날 때 까지 모든 case과 defeault를 실행한다.

## 8.3 반복문

: 조건식의 평과 결과가 참인 경우 코드 블록을 실행. 그 후 조건식을 다시 평가하여 여전히 참인 경우 다시 실행. 조건식이 거짓일 때 까지 반복

<aside>
💡 자바스크립트는 반복문을 대체 할 수 있는 다음과 같은 다양한 기능을 제공한다.
- 배열을 순회할 때 사용하는 `forEach` 메서드
- 프로퍼티를 열거할 때 사용하는 `for in` 문
- ES6에서 도입된 이터러블을 순회할 수 있는 `for of`문

</aside>

### 8.3.1 for 문

: 조건식이 거짓으로 평가될 때 까지 코드 블록을 반복 실행

```jsx
for (변수 선언문 또는 할당문; 조건식; 증감식) { 
	조건식이 참인 경우 반복 실행될 문;
}

for(var i=0; i<2; i++){
	console. log(i); 
}
```

### 8.3.1 while 문

: 주어진 조건식의 평과 결과가 참이면 코드 블록을 반복해서 실행

```jsx
var count = 0;
// count 가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다. 
while (count < 3) {
	console.log(count); // 0 1 2 
	count++;
}

// 무한루프
while (true) { ... }
```

### 8.3.1 do while 문

: 코드 블록을 먼저 실행하고 조건식을 평가

```jsx
var count = 0;
// count 가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다. 
do {
	console.log(count); // 0 1 2 
	count++;
} while (count < 3);
```

## 8.4 break 문

: 코드 블록을 탈출한다. 전확히는 레이블 문, 반복문, switch문의 코드블록을 탈출한다.

+) 그 외에 break문을 사용하면 SyntaxError가 발생한다.

레이블 문이란 식별자가 붙은 문을 말한다.

```jsx
// foo 라는 식별자가 붙은 레이블 블록문 
foo: {
	console. log(1);
	break foo; // foo레이블 블록문을 탈출한다.
	console. log(2); 
}
console. log('Done! ');
```

## 8.3 continue 문

: 반복문의 코드 블록 실행을 현 시점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.

```jsx
var string = 'Hello World.'; 
var search = '1';
var count = 0;

for (var i = 0; i < string.length; i++) {
	// 'l'이 아니면 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다. 
	if (string[i] !== search) continue;
	count++; // continue 문이 실행되면 이 문은 실행되지 않는다.
}
```

# 09 타입 변환과 단축 평가

## 9.1 타입 변환이란?

개발자가 의도적으로 타입을 변환하는 것을 `명시적 타입 변환` 또는 `타입 캐스팅` 이라 한다.

## 9.2 암묵적 타입 변환

자바 스크립트 엔진은 표현식을 평가할 때 개발자의 의도와는 상관없이 코드의 문맥을 고려해 암묵적으로 데이터 타입을 강제 변환한다.

### 9.2.1 문자열 타입으로 변환

```jsx
1 + '2' // -> '12'
```

### 9.2.2 숫자 타입으로 변환

```jsx
1 - '1' // -> 0
1 * '10' // -> 10
1 / 'one' // -> NaN

'1' > 0 // -> true
```

### 9.2.3 불리언 타입으로 변환

## 9.3 명시적 타입 변환

개발자의 의도에 따라 명시적으로 타입을 변경하는 방법

1. 표준 빌트인 생성자 함수(String, Number, Boolean)을 new연산자 없이 호출하는 방법
2. 빌트인 메서드를 사용하는 방법

### 9.3.1 문자열 타입으로 변환

```jsx
// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법
String(1); // -> '1'

// 2. Object.prototype.tostring 메서드를 사용하는 방법
(1).toString(); // -> '1'

// 3. 문자열 연결 연산자를 이용하는 방법
1 + ''; // -> '1'
```

### 9.3.2 숫자 타입으로 변환

```jsx
// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
Number('1'); // -> 1

// 2. parseInt.parseFLoat 함수를 사용하는 방법(문자열만 숫자타입으로 변환가능)
parseInt('1') // -> 1

// 3. + 단항 산술 연산자를 이용하는 방법
+'1'; // -> 1

// 4. * 산술 연산자를 이용하는 방법
'-1' * 1; // -> -1
```

### 9.3.3 불리언 타입으로 변환

```jsx
// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
Boolean('1'); // -> true
Boolean(''); // -> false
Boolean('false'); // -> true

Boolean(1); // -> true
Boolean(0); // -> false

Boolean({}); // -> true
Boolean([]); // -> true

// 2. ! 부정 논리 연산자를 두번 사용하는 방법
!!'1'; // -> true
!!''; // -> false
!!'false' // -> true

!!1; // -> true
!!0; // -> false

!!{}; // -> true
!![]; // -> true
```

# 9.4 단축 평가

### 9.4.1 논리 연산자를 이용한 단축 평가

- 논리곱 **`&&`**
    
    **`&&`** 연산자는 **`마지막으로 평가된 피연산자`**를 반환함
    
    ```jsx
    'Cat' && 'Dog' // -> "Dog" / Cat이 참이라서
    '' && 'Dog' // -> "" / ''가 flase라서 바로 반환
    ```
    
- 논리합 **`||`**
    
    논리 연산의 **`결과를 결정한 첫 번째 피연산자`**를 반환
    
    ```jsx
    'Cat' || 'Dog' // -> "Cat"
    ```
    

### 9.4.2 옵셔널 체이닝 연산자

ES11(ESMAScript2020)에서 도입

연산자 **`?.`**는 좌항의 피연산자가 null, undefined인 경우 undefined 반환

그렇지 않은 경우, 우항의 프로퍼티 참조

```jsx
var str = '';
var length = str?.length;
console. log(length); // 0
```

### 9.4.3 null 병합 연산자

ES11(ESMAScript2020)에서 도입

연산자 ?? 는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환

그렇지 않은 경우 좌항의 피연산자를 반환

```jsx
var foo = null ? 'default string';
console.log(foo); // "default string"
```

# 10 객체 리터럴

## 10.1 객체란?

자바스크립트는 객체 기반의 프로그래밍 언어이다.

자바스크립트를 구성하는 거의 모든것이 객체이다.

원시 값을 제외한 나머지 값은 모두 객체이다.

객체는 변경가능한 값이다.

## 10.2 객체 리터럴에 의한 객체 생성

C++과 자바같은 `클래스 기반의 객체지향언어`는 클래스를 사전에 정의하고 필요한 시점에 new연산자와 함께 생성자를 사용한다.

자바스크립트는 **`프로토타입 기반 객체지향 언어`**로써, 다음과 같은 방법을 지원한다.

- 객체 리터럴 **`{}`**
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)

```jsx
var empty = {}; // 빈객체 
console.log(typeof empty); // object
```

## 10.3 프로퍼티

객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.

```jsx
var person= {
	// 프로퍼티 키는 name, 프로퍼티 값은 'Lee' 
	name: 'Lee',
	age : 20,
};

console.log(person.name) // Lee
```

## 10.4 메서드

자바스크립트의 함수는 객체(일급 객체)이다.

함수는 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용가능하다.

```jsx
var circle = {
	radius: 5,

	getDiameter: function(){
		return 2 * this.radius;
	}
};

console.log(circle.getDiameter()); // 10
```

## 10.5 프로퍼티 접근

프로퍼티에 접근하는 방법

- 마침표 표기법 (**`.`** 이용)
- 대괄호 표기법 (**`[…]`** 사용)

```jsx
var person = {
	name: 'Lee'
};

// 마침표 표기법
console.log(person.name); // Lee

// 대괄호 표기법
console.log(person['name' ]); // Lee
```

+) 대괄호 표기법 사용시 `프로퍼티키는 반드시 따옴표로 감싼 **문자열**`이어야 한다.

## 10.6 프로퍼티 값 갱신

존재하는 프로퍼티에 값을 할당하면 된다.

```jsx
person.name = "Kim"
```

## 10.7 프로퍼티 동적 생성

존재하지 않는 프로퍼티에 값을 할당하면 동적으로 추가된다.

```jsx
var person = {
	name: 'Lee'
};

person.age = 20;
// person 객체에 age 프로퍼티가 동적으로 생성되고 값이 할당 됨.
```

## 10.8 프로퍼티 삭제

**`delete`** 연산자가 객체의 프로퍼티를 삭제함

+) 존재하지 않는 프로퍼티 삭제 시 **아무 에러없이 무시**된다.

```jsx
delete person.age;
```

## 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

### 10.9.1 프로퍼티 축약 표현

```jsx
var x = 1, y = 2;

// ES5
var obj = { 
	x: x,
	у: У
};

// ES6
const obj = { x, y };
```

### 10.9.2 계산된 프로퍼티 이름

```jsx
var prefix = 'prop';
var i =0;

// ES5
var obj = {};
obj[prefix +'-'+ ++i] = i;

// ES6
const obj = {
	['$(prefix}-${++i}']: i,
};
```

### 10.9.3 메서드 축약 표현

ES6에서는 function키워드를 생략한 축약 표현 사용

```jsx
// ES5
var obj = {
	name: 'Lee',
	sayHi: function() {
		console.log('Hi! ' + this.name); 
	}
};

// ES6
const obj = {
	name: 'Lee',
	sayHi() {
		console.log('Hi! ' + this.name); 
	}
};
```

# 11 원시 값과 객체의 비교

원시 타입 → 변경 불가능한 값

객체 타입 → 변경이 가능한 값

## 11.1 원시 값

## 11.2 객체

### 11.2.1 변경 가능한 값

객체는 **`여러개의 식별자가 하나의 객체를 공유`**할 수 있다.

```jsx
const o = { x : { y : 1 } };

// 얕은 복사
const c1 = { ... o };
console.log(c1 === o); // false 
console.log(c1.x === o.x); // true

// 깊은 복사
const c1 = _.cloneDeep(o);
console.log(c1 === o); // false 
console.log(c1.x === o.x); // false
```

<aside>
💡 자바스크립트의 얕은 복사와 깊은 복사

얕은 복사는 객체에 중첩되어있는 객체의 경우 참조 값을 복사
깊은 복사는 객체에 중첩되어있는 객체까지 모두 복사

</aside>

### 11.2.2 참조에 의한 전달

# 12 함수

## 12.1 함수란?

프로그래밍 언어의 함수는 일련의 과정을 문으로 구현하고 코드블록으로 감싸서 하나의 실행단위로 정의한 것.

## 12.4 함수 정의

함수 정의방식

- 함수 선언문
- 함수 표현식
- Function 생성자 함수
- 화살표 함수 (ES6)

### 12.4.1 함수 선언문

```jsx
function add(x, y) {
	return x + y;
};
```

### 12.4.2 함수 표현식

```jsx
var add = function (x, y) {
	return x + y;
};
```

### 12.4.3 함수 생성 시점과 함수 호이스팅

**함수 선언문으로 정의한 함수**는 **`함수 선언문 이전에 호출`**할 수 있다.

런타임에는 이미 함수 객체가 생성되어있고, 함수 이름과 동일한 식별자에 할당까지 완료된 상태

→ **`함수 호이스팅`**

변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수표현식의 함수리터
럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.

→ 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 **변수 호이스팅**이 발생 한다.

### 12.4.4 Function 생성자 함수

```jsx
var add = new Function('x', 'y', 'return x + y');

console. log(add(2, 5)); // 7
```

### 12.4.5 화살표 함수

```jsx
const add = (x, y) => x + y;

console.log(add(2, 5)); // 7
```

- 화살표 함수는 생성자 함수로 사용할 수 없다.
- prototype 프로퍼티가 없다.
- arguments 객체를 생성하지 않는다.

## 12.6 참조에 의한 전달과 외부 상태의 변경

![Untitled](8,%209,%2010,%2011,%2012%20b6dc33f201e440fca191d96f851d0c3f/Untitled.png)

## 12.7 다양한 함수의 형태

### 12.7.1 콜백 함수

 : 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수

고차함수

 : 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수

고차함수는 콜백함수를 자신의 일부분으로 합성한다.
