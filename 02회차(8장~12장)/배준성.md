## 8장 제어문

### 블록문

- 블록분 = 0개 이상의 문을 중괄호로 묶은것. js에서는 하나의 실행단위.

### 조건문

- 조건문 = 조건식의 평가 결과에 따라 코드 블록의 실행을 결정한다.

if else, switch 문

### 반복문

- 반복문 = 조건식의 평가 결과가 참인 경우 코드 블록을 실행한다.

for, while, do while 문

### break 문

- break 문 = 코드 블록(레이블 문, 반복문, switch 문)을 탈출한다. 이외의 코드 블록에서 break를 사용하면 SyntaxError가 발생한다.

##### 레이블 문은 식별자가 붙은 문이다.
```javascirpt
// e.g. foo 식별자가 붙은 레이블 문. 'break 레이블;'으로 특정한 함수를 탈출하고 싶을 때 주로 사용.
foo: console.log('foo');
```

### continue 문

- continue 문 = 반복문의 코드 블록 실행을 현 시점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다. 쉽게 말해서 실행중인 블록의 나머지 코드를 뛰어넘고 다음 실행으로 넘어가는 기능이다.

## 9장 타입 변환과 단축 평가

### 타입 변환이란?

- 명시적 타입 변환(타입 캐스팅) = 개발자가 의도적으로 값의 타입을 변환.
- 암묵적 타입 변환(타입 강제 변환) = JS엔진에 의해 암묵적으로 타입이 자동 변환.

원시 값은 변경이 불가능하기 때문에 타입 변환은 기존의 원시 값을 바탕으로 새로운 원시 값을 생성하는 것이다.

### 암묵적 타입 변환

암묵적 타입 변환이 발생하면 원시 타입 중 하나로 타입을 자동으로 변환한다.

##### 문자열 타입으로 변환

- 문자열 연결 연산자 '+'
- 템플릿 리터럴의 표현식 삽입

##### 숫자 타입으로 변환

- 산술 연산자 '-', '*', '/'
- 비교 연산자 '>', ...
- '+' 단항 연산자

##### 불리언 타입으로 변환

- Boolean 생성자 함수를 new 없이 호출
- 부정 논리 연산자 '!'를 두번 사용

### 단축 평가

#### 단축 평가

- 논리곱(&&) =  개의 피연산자가 모두 true로 평가될 때 true 리턴. 좌항->우항 으로 평가 진행. 좌항이 true이면 우항을 그대로 리턴.
- 논리합(||) = 두 개의 피연산자 중 하나만 true로 평가되어도 true를 리턴. 좌항->우항으로 평가 진행. 좌항이 true이면 좌항을 그대로 리턴. 좌항이 false이면 우항을 그대로 리턴.

##### 단축 평가 = 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 변환한다. 표현식 평가중 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것.

![alt text](image.png)

#### 옵셔널 체이닝
옵셔널 체이닝 연산자(?.) 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 리턴, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.

#### null 병합 연산자

null 병합 연산자(??) 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 리턴, 그렇지 않으면 좌항의 피연산자를 반환한다. 변수 기본값 설정 시 유용.

- 옵셔널 체이닝으로 &&를 대체 가능.
- null 병합 연산자로 ||를 대체 가능.

## 10장 객체 리터럴

### 객체란?

JS에서 원시 값을 제외한 나머지 값은 모두 객체로 되어있다.
객체는 원시 값과 다르게 변경 가능한 값이다.
객체는 0개 이상의 프로퍼티로 구성된 집합이다. 프로퍼티는 키와 값으로 구성된다.
자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용 가능하다. 이런 경우 일반 함수와 구분하기 위해서 메서드라고 부른다.
따라서 객체는 프로퍼티와 메서드로 이루어져있다.
- 프로퍼티 = 객체의 상태를 나타내는 값.
- 메서드 = 프로퍼티를 참조하고 조작할 수 있는 동작.

### 객체 리터럴에 의한 객체 생성

JS의 객체 생성 방법
- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스

### 프로퍼티

- 키 = 빈 문자열을 포함하는 모든 문자열 또는 심벌 값
- 값 = 자바스크립트에서 사용할 수 있는 모든 값

식별자 네이밍을 다르지 않는 키는 반드시 따옴표 사용.
표현식을 사용해 키를 동적으로 생성한다면, 키로 사용할 프로퍼티를 대괄호([...])로 묶어야함.

### 메서드

자바스크립트의 함수는 일급 객체이다. 따라서 프로퍼티 값으로 사용 가능하다.
(일급 객체 18.1 절 참조)

### 프로퍼티 접근

- 마침표 표기법 = 마침표 프로퍼티 접근 연산자(.) 사용.
- 대괄포 표기법 = 대괄호 프로퍼티 접근 연산자([...]) 사용. 대괄호 프로퍼티 접근 연산자 내부에서 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. 프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않으면 반드시 대괄호 표기법을 사용해야 한다.

객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 리턴한다.

### 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.

### 프로퍼티 동적 생성

존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.

### 프로퍼티 삭제

delete 연산자는 객체의 프로퍼티를 삭제한다. 존재하지 않는 프로퍼티 삭제하면 에러 없이 무시된다.

### ES6에서 추가된 객체 리터럴의 확장 기능

#### 프로퍼티 축약 표현

프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 같으면 키를 생략할 수 있다. 변수 이름으로 키가 자동 생성된다.

#### 계산된 프로퍼티 이름

객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성 가능.

#### 메서드 축약 표현

메서드 정의 시 function 키워드 생략 가능

## 11장 원시 값과 객체의 비교

### 원시 값

변경 불가능한 값
하지만 변수는 재할당을 통해서 변경 가능.
참조하는 메모리 주소값을 교체하는 방식으로 변경(재할당).
이러한 특성을 **불변성** 이라고 함.

#### 문자열 불변성

문자열은 유사 배열 객체이면서 이터러블 -> 배열과 유사하게 각 문자에 접근 가능하다.
문자열도 원시 값이라 수정이 불가능하다.

### 객체

객체는 프로퍼티 개수가 정해져있지 않고, 동적으로 추가되고 삭제될 수 있음.

#### 변경 가능한 값

객체는 변경 가능한 값이다. 재할당 없이 객체를 직접 변경할 수 있다. 동적으로 추가, 갱신, 삭제 모두 가능하다.
하지만 여러 개의 식별자가 하나의 객체를 공유할 수 있기 때문에 주의해야한다.

#### 참조에 의한 전달

여러 개의 식별자가 하나의 객체를 공유할 수 있기 때문에 같은 객체를 공유하는 식별자는 객체의 변경에 대해서 서로 영향을 주고받는다.
객체 리터럴은 평가 될 때마다 객체를 생성하기 때문에 같은 리터럴을 통해서 생성해도 서로 다른 객체이다.

## 12장 함수

### 함수란?

함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.

### 함수를 사용하는 이유

코드의 재사용 때문에 사용한다.

### 함수 리터럴

자바스크립트의 함수는 객체 타입의 값이다.
따라서 함수도 함수 리터럴로 생성할 수 있다.
일반 객체와는 다르게 함수는 호출할 수 있다.

### 함수 정의

함수 정의 방식

![alt text](image-1.png)

#### 함수 선언문

```javascript
// 함수 선언문
function add(a, b) {
  return a + b;
};
```

함수 선언문은 함수 이름을 생략할 수 없다. 또한 표현식이 아닌 문이다.

#### 함수 표현식
```javascript
// 함수 표현식
var add = function (a, b) {
  return a + b;
};
```

JS 함수는 값처럼 변수에 할당할 수도 있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수도 있다. 이처럼 값의 성질을 갖는 객체를 **일급 객체**라고 한다. JS에서 함수는 일급 객체이다.
함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다.(일급 객체이므로)
이러한 정의 방식으로 **함수 표현식**이라고 한다.
함수 선언문은 *표현식이 아닌 문*이고 함수 표현식은 *표현식인 문*이다.

#### 함수 생성 시점과 함수 호이스팅

- 함수 호이스팅 = 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

변수 할당문의 값은 할당문이 실행되는 시점(런타임)에 평가된다.
함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.
따라서 함수 표현식으로 함수를 정의하면 변수 호이스팅이 발생한다.
그래서 함수 표현식 이전에 함수를 참조하면 undefined로 평가된다. 이때 함수를 호출하면 undefined를 호출하는 것과 마찬가지이므로 타입 에러가 발생한다.

#### Function 생성자 함수

#### 화살표 함수

### 함수 호출

#### 매개변수화 인수

#### 인수 확인

#### 매개변수의 최대 개수

#### 반환문

### 참조에 의한 전달과 외부 상태의 변경

### 다양한 함수의 형태

#### 즉시 실행 함수

#### 재귀 함수

#### 중첩 함수

#### 콜백 함수

#### 순수 함수와 비순수 함수