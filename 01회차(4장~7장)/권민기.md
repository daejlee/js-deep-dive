# 04 변수

## 4.1 변수란 무엇인가? 왜 필요한가?

```js
10 + 20
```

자바스크립트 엔진은 `+연산`을 수행하기위해 피연산자 10, 20 을 기억한다.

컴퓨터는 CPU를 사용해 연산하고 메모리를 사용해 데이터를 기억한다.

메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체이다.

메모리 셀 하나 의 크기 = 1byte(8bit)

각 메모리 셀은 메모리 주소를 가진다. 메모리 공간의 위치를 나타낸다.

<img width="539" alt="image" src="https://github.com/daejlee/js-deep-dive/assets/80528044/2d87355b-7123-4244-8714-8fe68c6766ab">

**변수**는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이다. (값의 위치를 가리키는 상징적인 이름)

상징적 이름의 변수는 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환된다.

```jsx
var res = 10 + 20;
```

생성된 새로운 값 30은 메모리 공간에 저장된다. 

<img width="539" alt="image" src="https://github.com/daejlee/js-deep-dive/assets/80528044/5cc94c57-1f08-45ea-bddb-e77cf4f7d7bf">

- **변수 이름(변수 명)** : 메모리 공간에 저장된 값을 식별할 수 있는 **고유한 이름** (위 사진에서 **result**)
- **변수 값** : 변수에 저장된 **값** (위 사진에서 **30**)
- **할당(대입, 저장)** : 변수에 값을 **저장**하는 것
- **참조** : 변수에 저장된 값을 읽어들이는 것

<aside>
💡 코드는 컴퓨터에게 내리는 명령이지만 개발자를 위한 문서이기도 하다. 개발자의 의도를나타내는 명확한 네이밍은 코드를 이해하기 쉽게 만들며, 이는 협업과 품질향상에도움을준다. 변수 이름은 심사숙고해서 지어야한다.

</aside>

## 4.2 식별자

**: 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.**

식별자는 메모리 주소를 기억하고 있다.

<img width="533" alt="image" src="https://github.com/daejlee/js-deep-dive/assets/80528044/fd3997fb-52cd-4aca-aa46-e087339ee243">


변수, 함수, 클래스 등의 이름은 모두 식별자이다. **선언**에 의해 자바스크립트 엔진에 식별자의 존재를 알릴 수 있다.

## 4.3 변수선언

**: 변수를 생성하는 것**

값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결하여 값을 저장 할 수 있게 준비하는 것.

변수 선언에 확보된 공간은 해제되기 전까지 누구도 확보된 메모리 공간을 사용할 수 없도록 보호된다.

자바스크립트에서 변수를 선언 할 때 사용하는 키워드는 `var`, `let`, `const` 이다.

변수를 선언하면 자바스크립트 엔진에 의해 `undefined`가 할당되어 초기화된다.

**var 변수 선언**

변수 선언 단계와 초기화 단계가 동시에 선언된다. (ex. 변수 score 등록 + undefined 할당)

<aside>
💡 초기화 단계를 거치지 않으면 확보된 메모리 공간에 이전에 사용했던 값인 **쓰레기 값**이 남아있을 수 있다.

</aside>

선언하지 않은 식별자에 접근하면 `ReferenceError`(참조에러) 가 발생한다. 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러이다.

## 4.4 변수선언의 실행 시점과 변수 호이스팅

```jsx
console.log(score); // undefined
var score; // 변수 선언문
```

위 예제에서는 score 변수 선언문 전에 콘솔 로그에서 score를 참고하고 있다. 따라서 **참조 에러**가 발생해야 할 것 같지만, 에러가 아닌 **undefined**이 출력된다.

변수 선언이 **`런타임`**이 아니라 **`그 전 단계`**에서 먼저 실행되기 때문이다. 

자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기 전, 소스코드의 평가 과정을 거치면서 **실행 준비 단계**를 거친다. 자바스크립트 엔진은 변수 선언을 포함한 **`모든 선언문을 찾아서 먼저 실행`**한다. 이후, 선언문을 제외하고 **`소스코드를 한 줄씩 순차적으로 실행`**한다.

이 처럼, 변수 선언문이 코드의 선두로 끌어 올려진 것 처럼 동작하는 자바스크립트의 특징을 **`변수 호이스팅`**이라 한다.

<aside>
💡 사실 변수 선언뿐 아니라 var, let , const , function, function*, class 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스등)는 호이스팅된다. 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.

</aside>

## 4.5 값의 할당

변수에 값을 할당(대입, 저장)할 때 **`할당 연산자 =`** 를 사용한다. 할당 연산자는 우변의 값을 좌변의 변수에 할당한다.

```jsx
// 변수 선언 후 값의 할당
var score;
score = 80;

// 변수 선언과 값의 할당
var score = 80;
```

변수 선언과 값의 할당 실행시점은 다르다. (하나의 문장으로 단축 표현 했을때도 2개의 문장으로 나뉘어 각각 실행된다.)

- 변수선언 : 런타임 이전에 먼저 실행
- 값의 할당 : 런타임 시점에 실행

<img width="536" alt="image" src="https://github.com/daejlee/js-deep-dive/assets/80528044/ca588c94-c627-4de0-a313-81ef87b57d78">


변수에 값을 할당 할 때, undefined가 저장되어있던 공간을 지우는 것이 아니라, **새로운 공간을 확보**하여 80 값을 할당한다.

예제 4-10

```jsx
console.log(score); // undefined
score = 80; // 값의 할당
var score; // 변수 선언
console.log(score); // 80
```

## 4.6 값의 재할당

**: 할당 되어있는 변수에 새로운 값을 다시 할당하는 것을 말한다.**

```jsx
var score= 80;    // 변수 선언과 값의 할당 
score = 90;    // 값의 재할당
```

var 키워드로 선언한 변수들은 재할당 할 수 있다.

값을 재할당 할 수 없어서 변수에 저장된 값을 변경할 수 없다면 **`상수`**라 한다.

<aside>
💡 **`const`**
ES6에 도입된 키워드
const 키워드를 사용해 선언한 변수는 재할당이 금지된다.

</aside>

<img width="539" alt="image" src="https://github.com/daejlee/js-deep-dive/assets/80528044/cad5440b-76c2-4f5a-83b9-2c19eb0e947b">


변수 값을 재할당하면 새로운 공간을 확보하고 값 90을 저장한다.

score변수의 이전값인 undefined와 80은 어느 식별자와도 연결되어 있지 않다. 이런 불필요한 값들은 **`가비지 콜렉터`**에 의해 **`메모리에서 자동 해제`**된다.

## 4.7 식별자 네이밍 규칙

식별자는 다음과 같은 네이밍 규칙을 준수해야한다.

- 특수문자를 제외한 문자, 숫자, _, $를 포함할 수 있다.
- 식별자를는 특수문자를 제외한 문자, _, $로 시작해야한다. (숫자로 시작될 수 없다.)
- 예약어는 식별자로 사용될 수 없다.
    

```jsx
// Good
var person;
var name, $elem, _name, first_name, name1; // ,로 구분되어 한번에 여러 개 선언 가능

// Bad
var 이름;
var first-name;    // SyntaxError: Unexpected token -
var 1st;    // SyntaxError: Invalid or unexpected token
var this;    // SyntaxError: Unexpected token this
```

자바스크립트는 대소문자를 구별한다. 다음의 변수는 각각 별개의 변수이다.

```jsx
var name;
var Name;
var NAME;
```

- 변수 이름은 변수의 존재 목적을 쉽게 이해랄 수 있도록 의미를 명확히 표현해야한다.
- 변수 선언에 별도의 주석이 필요하다면 존재 목적을 명확히 드러내지 못하는 것이다.
- 네이밍 컨벤션 예시
    - 카멜 케이스 (camelCase)
    - 스네이크 케이스 (snake_case)
    - 파스칼 케이스 (PascalCase)
    - 헝가리언 케이스 (typeHungarianCase) // type + PascalCase

# 05 표현식과 문

## 5.1 값

**: 식(표현식)이 평가되어 생성된 결과**

```jsx
var sum = 10 + 20;
```

변수 sum에는 위 식의 **결과 값**인 숫자 **30**이 저장된다.

## 5.2 리터럴

**: 사람이 이해할 수 있는 문자 또는 약속된 기로를 사용해 값을 생성하는 표기법**

- 사람이 이해할 수 있는 문자 (아라비아 숫자, 알파벳, 한글)
- 미리 약속된 기호 (’’, “”, ., [], {} 등등)

자바스크립트 엔진은 런타임에 리터럴을 평가해 값을 생성한다.
    

## 5.3 표현식 (expression)

**: 값으로 평가될 수 있는 문. 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.**

리터럴도 표현식이다.

값으로 평가될 수 있는 문은 모두 표현식이다.

```jsx
// 리터럴 표현식 
10
'Hello'

// 식별자 표현식(선언이 이미 존재한다고 가정)
Sum
person.name
arr[1]

// 연산자 표현식
10 * 20
sum = 10
sum !== 10

// 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)
square( )
person getName()
```

## 5.4 문 (statement)

**: 프로그램을 구성하는 기본 단위이자 최소 실행 단위**

문은 여러 토큰으로 구성된다.

토근(token) : 문법적인 의미를 가지며, 문법적으로 더이상 나눌 수 없는 코드의 기본요소

<img width="538" alt="image" src="https://github.com/daejlee/js-deep-dive/assets/80528044/0e20937f-34ff-4b54-9266-96f00f62c216">


문은 선언문, 할당문, 조건문, 반복문 등으로 구분 할 수 있다.

```jsx
// 변수선언문 
var x;

// 할당문 
×= 5;

// 함수선언문
function foo () (}

// 조건문
if (x >1) { console. 10g(x); }

1\// 반복문
for (var i = 0; i < 2; i++) { console. log(i); }
```

## 5.5 세미콜론과 세미콜론 자동 삽입 기능

**세미콜론(;)** : **`문의 종료`**를 나타낸다.

자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고, 순차적으로 하나씩 문을 실행한다. if, for, 함수 등 코드블록 뒤에는 세미콜론을 붙이지 않는다.(자체 종결성을 가지기 때문)

세미콜론은 **생략가능**한다.

자바스크립트 엔진이 소스코드를 해석할 때, 문의 끝이라고 예측되는 지점에 자동으로 세미콜론을 붙여주는 ASI기능이 암묵적으로 수행된다.

## 5.6 표현식인 문과 표현식이 아닌 문

표현식은 문의 일부일 수 있고, 그 자체로도 문이 될 수 있다.

```jsx
// 표현식이 아님. 값으로 평가될 수 없음
var x;

// 표현식이면서 완전한 문
x = 1 + 2;
```

표현식인 문과 표현식이 아닌 문을 구별하는 방법은 변수에 할당해 보는 것이다.

```jsx
// 표현식이 아님
var foo = var x;

// 표현식
var foo = x = 1 + 2;
```

# 06 데이터 타입

자바스크립트(ES6)는 7개의 데이터 타입을 제공한다.

<img width="552" alt="image" src="https://github.com/daejlee/js-deep-dive/assets/80528044/b080bd23-7c25-47a3-b465-9a4681fbe123">


## 6.1 숫자 타입

<aside>
💡 C, Java - 정수, 실수를 구분함 (int, float 등)

JS - **하나의 숫자 타입**만 존재

</aside>

정수, 실수, 2진수, 8진수, 16진수 리터럴 **모두** **`부동소수점 형식의 2진수`**로 저장된다.

자바 스크립트는 정수만을 위한 타입이 **없다** → 모든 수를 **`실수`**로 처리한다.

```jsx
console.log(1 === 1.0); // true
console.log(4 / 2); // 2 
console.log(3 / 2); // 1.5
```

숫자 타입은 추가적으로 특별한 값도 표현할 수 있다.

- Infinity : 양의 무한대
- -Infinity : 음의 무한대
- NaN : 산술 연산 불가(not-a-number)

```jsx
console.log(10 / 0); // Infinity 
console.log(10 / -0); // -Infinity 
console.log(1 * 'String'); // NaN
```

+) 자바스크립트는 대소문자를 구별하므로 NAN, Nan, nan과 같이 표현해서는 안된다.

## 6.2 문자열 타입

텍스트 데이터를 나타내는 데 사용된다.

문자열은 0개 이상의 16비트 **유니코드 문자의 집합**이다.

문자열은 작은따옴표(`’’`), 큰따옴표(`””`), 백틱(````)으로 텍스트를 감싼다.

```jsx
var string;
string= '문자열'; // 작은따옴표 
string= "문자열"; // 큰따옴표
string= `문자열`; // 백틱(ES6)
```

자바스크립트의 문자열은 **`원시 타입`**이며, **`변경이 불가능한 값`**이다.

+) C - 문자열 타입 없음. 문자열 배열로 문자열을 표현 / java - 문자열을 객체로 표현

## 6.3 템플릿 리터럴

ES6부터 새로운 문자열 표기법인 템플릿 리터럴이 도입

멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 **문자열 처리기능**을 제공

따옴표 대신 백틱(````)을 사용해서 표현

### 6.3.1 멀티라인 문자열

템플릿 리터럴 내에서는 개행 및 모든 줄바꿈이 허용된다.

일반 문자열 내에서는 개행이 허용되지 않는다.

```jsx
// 일반 문자열 내에서 개행 허용 X
var str = "줄바꿈
줄바꿈";
// SyntaxError: Invalid or unexpected token

// 일반 문자열 내에서 개행 삽입
var str = "줄바꿈\n줄바꿈";

// 템플릿 리터럴에서 개행 허용 O
var str `줄바꿈
줄바꿈`;
```

### 6.3.2 표현식 삽입

문자열은 `문자열 연산자 **+**` 를 사용해서 연결 가능

템플릿 리터럴 내에서는 표현식 삽입이 가능. **`${}`** 으로 표현식을 감싸야 함.

표현식은 반드시 템플릿 리터럴 내에서 사용해야하며, 일반 문자열에는 문자로 취급 됨

```jsx
var name = 'name';

// ES5
console.log('my name is' + name); 

// ES6
console.log(`my name is ${name}`); 
```

## 6.4 불리언 타입

- 참 : **`true`**
- 거짓 : **`flase`**

## 6.5 undefined 타입

var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화된다. 다시말해, 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때 까지 빈 상태 (쓰레기 값)로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화한다. 

따라서 변수를 선언한 이후 값을 할당하지 않은 변수를 참조하면 undefined가 반환된다.

<aside>
💡 자바스크립트 엔진이 변수를 초기화하는데 사용하는 **`undefined`**를 개발자가 의도적으로 변수에 할당한다면 본래 취지와 어긋날 뿐더러 혼란을 줄 수 있으므로 권장하지 않는다. 변수에 값이 없음을 명시하고 싶다면 **`undefined`**를 할당하는 것이 아니라 **`null`**을 할당해야한다.

</aside>

## 6.6 null 타입

대소문자를 구별하므로 **`null`**을 Null, NULL과 같이 쓰일 수 없다.

null은 변수에 값이 없다는 것을 **의도적으로 명시**하기위해 사용한다.

함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다.

## 6.7 심벌 타입

ES6에 추가된 타입으로, 변경 불가능한 원시 타입이다.

심벌 값은 다른 값과 **`중복되지않는 유일무이한 값`**이다.

심벌은 **`Symbol 함수`**를 호출해서 생성된다. 생성된 심벌은 외부에 노출되지 않는다.

```jsx
// 심벌 값 생성
var key = Symbol('key');

// 충돌 할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용
var obj = {};
obj[key] = 'value'
```

33장에서 자세히 설명

## 6.8 객체 타입

자바스크립트는 **`객체 기반의 언어`**이며 자바스크립트를 이루는 거의 모든 것은 객체이다.

위 6가지 데이터 타입 이외의 값은 모두 **객체타입**이다.

11장에서 자세히 설명

## 6.9 데이터 타입의 필요성

### 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조

- 값을 저장하는 경우
    
    ```jsx
    var score = 100;
    ```
    
    자바스크립트 엔진은 8byte의 메모리 공간을 확보한 후, 숫자 100을 2진수로 저장한다.
    
- 값을 참조하는 경우
    
    식별자 score을 통하여 100이 저장되어있는 메모리 공간의 주소를 찾아간다. 한 번에 읽어들여야 하는 메모리 공간의 크기를 알아내어 읽는다. socre변수에는 숫자 타입의 값이 할당되어 있으므로 8byte 단위로 값을 읽어들인다.
    

### 6.9.2 데이터 타입에 의한 값의 해석

메모리에서 읽어들인 2진수를 해석되는 방법은 다를 수 있다.

ex. 값 `0100 0001`을 숫자로 해석하면 `65`, 문자로 해석하면 `A`이다.

데이터 타입이 필요한 이유

- 값을 저장할 때 확보해야하는 메모리 공간의 크기를 결정하기 위함
- 값을 참조할 때 한번에 읽어들여야 할 메모리 공간의 크기를 결정하기 위함
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위함

## 6.10 동적 타이핑

### 6.10.1 동적 타입 언어와 정적 타입 언어

변수는 어떤 데이터 타입을 가지는가.

- **정적 타입 언어 -** C, Java
    - 데이터 타입을 사전에 선언함
    - 변수의 타입을 변경할 수 없음
    - 컴파일 시점에 **`타입 체크`**가 수행 됨.
- **동적 타입 언어 -** 자바스크립트
    - 변수 선언 시, 타입이 아니라 키워드(const, let, var)를 사용
    - 어떤 데이터의 타입이라도 할당이 가능
    - 할당에 의해 타입이 결정 - **`타입 추론`**
    - 변수의 타입은 언제든지 동적으로 변할 수 있음 - **`동적 타이핑`**

### 6.10.2 동적 타입 언어와 변수

- 장점
    - 자유로운 할당
    - 편리
- 단점
    - 변수 값 추적이 어려움
    - 자바스크립트의 엔진에 의해 타입이 변환될 수 있음 (유연성이 높지만 신뢰성이 떨어짐)

변수 사용시 주의 사항

- 변수는 꼭 필요한 경우 제한적으로 사용한다.
- 변수의 유효범위(스코프)는 최대한 좁게 만들어 부작용을 억제한다.
- 전역 변수는 최대한 사용하지 않도록 한다.
- 변수보다는 상수를 사용해 값의 변경을 억제한다.
- 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.

# 07 연산자

하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산등을 수행하여 하나의 값을 만든다.

## 7.1 산술 연산자

피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산이 불가능 한 경우, NaN이 반환된다.

### 7.1.1 이항 산술 연산자

**2개의 피연산자**를 산술 연산하여 숫자 값을 만든다.

<img width="502" alt="image" src="https://github.com/daejlee/js-deep-dive/assets/80528044/869bcf4f-faae-4746-bb2f-1297591c0298">


### 7.1.2 단항 산술 연산자

**1개의 피연산자**를 산술 연산하여 숫자 값을 만든다.

<img width="539" alt="image" src="https://github.com/daejlee/js-deep-dive/assets/80528044/da57b0ee-2bc4-4ca2-9cb2-a579bea42bc4">


### 7.1.3 문자열 연결 연산자

**`+연산자`**는 피연산자 중 하나 이상이 문자열인 경우, **`문자열 연결 연산자`**로 동작한다.

```jsx
// 산술 연산자 
1 + 2; // -> 3

// 문자열 연결 연산자
'1' +'2' // -> '12'
1 +'2' // -> '12'

// true는 1로, false는 0으로 변환
1 + true // -> 2

// null은 0으로 변환
1 + null // -> 1

// undefined는 숫자로 타입 변환 X
1 + undefined // -> Nan
```

자바스크립트 엔진에 의해 암묵적으로 **`타입이 자동 변환`** 되는 걸 확인 할 수 있다.

이를 `암묵적 타입 변환(implicit coercioin)` 또는 `타입 강제 변환(type coercion)`이라고 한다.

## 7.2 할당 연산자

우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당

<img width="500" alt="image" src="https://github.com/daejlee/js-deep-dive/assets/80528044/0bb2c7dc-b168-4699-ab37-9ff66eef4640">


할당문은 값으로 평가되는 표현식인 문으로써 **할당된 값**으로 평가된다.

연쇄 할당 가능 (ex. a = b = c = 0;)

## 7.3 비교 연산자

좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.

제어문의 조건식(if, for)에서 주로 이용된다.

### 7.3.1 동등/일치 비교 연산자

- 동등 비교 연산자
    - **느슨한 비교**
    - `암묵적 타입 변환`을 통해 타입을 일치시킨 후 비교
- 일치 비교 연산자
    - **엄격한 비교**
    - 타입도 같고 값도 같은 경우에만 true 반환
<img width="498" alt="image" src="https://github.com/daejlee/js-deep-dive/assets/80528044/b90b0ab8-f8ab-4232-8130-3a2b2f0a82c9">


### 7.3.2 대소 관계 비교 연산자

피연산자의 크기를 비교하여 불리언 값을 반환한다.

<img width="554" alt="image" src="https://github.com/daejlee/js-deep-dive/assets/80528044/0ffab739-671a-4b8f-b369-871802672a13">


## 7.4 삼항 조건 연산자

조건식의 평가 결과에 따라 반환할 값을 결정한다.

```jsx
// 조건식 ? 조건식이 true일 때 반환값 : 조건식이 false일 때 반환 값
var res = score > 60 ? 'P' : 'F';

// 아래 if/else문과 동일
var res;
if(score > 60){
	res = 'P';
} else {
	res = 'F';
}
```

**삼항 조건 연산자 표현식은 값으로 평가할 수 있는 `표현식인 문`이다.**

삼항연산자 표현식을 값으로 이용 가능 (if/else 문은 표현식이 아닌 문 → 값으로 이용 불가능)

## 7.5 논리 연산자

우항과 좌항의 피연산자를 논리 연산

<img width="546" alt="image" src="https://github.com/daejlee/js-deep-dive/assets/80528044/a1350a59-c6b0-426d-91db-03686164e787">


- !
    - 언제나 불리언 값 반환
- ||, &&
    - 결과가 불리언값이 아닐 수 있음
        
        ```jsx
        'Cat' & 'Dog'; // -> 'Dog'
        ```
        

## 7.6 쉼표 연산자

왼쪽 피연산자부터 차례대로 피연산자를 평가하고, 마지막 피연산자의 평가 결과를 반환한다.

```jsx
var x, y, z;
x = 1, y = 2, z = 3;
```

## 7.7 그룹 연산자

소괄호 ()로 피연산자를 감싸면 우선 순위가 높아진다. 그룹 연산자는 연산자 우선순위가 가장 높다.

```jsx
10 * 2 + 3; // -> 23
10 * (2 + 3); // -> 50
```

## 7.8 typeof 연산자

피연산자의 데이터 타입을 **`문자열`**로 반환

string, number, boolean, undefined, symbol, object, function 중 하나를 반환한다.

(null을 반환하는 경우는 없다. typeof로 null을 연산하면 object가 반환된다.)

## 7.9 지수 연산자

ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭제곱한다.

```jsx
// ES7
2 ** 2; // -> 4
2 ** 2.5; // -> 5.65685424949238

// Math.pow 메서드
Math.pow(2, 2);
Math.pow(2, 2.5);
```

+) 지수 연산자는 이항 연산자 중에서 우선 순위가 가장 높다.

## 7.10 그 외의 연산자

<img width="546" alt="image" src="https://github.com/daejlee/js-deep-dive/assets/80528044/8e5b690e-2c6d-45e0-ac25-d7922f735b09">


## 7.11 연산자의 부수 효과

다른 코드에 영향을 주는 부수효과가 있는 연산자는 다음과 같다.

- 할당 연산자 `=`
- 증가 연산자 `++`
- 감소 연산자 `--`
- `delete` 연산자

## 7.12 연산자 우선순위

우선순위가 높을수록 먼저 실행된다.

<img width="551" alt="image" src="https://github.com/daejlee/js-deep-dive/assets/80528044/ce623bcf-9553-47e2-95e0-00a93f7be51a">


## 7.13 연산자 결합 순서

좌항과 우항 중, 어느 쪽 부터 평가를 수행할 것인지 나타내는 순서

<img width="539" alt="image" src="https://github.com/daejlee/js-deep-dive/assets/80528044/56af38a6-c2cb-4291-874c-5702a30d4512">

---

## 알게된 점

var를 사용하지 않아서 잘 몰랐는데 이번 기회에 자세하게 알게되었다.

---

## 질문 리스트

- var을 지양해야하는 이유
- 자바스크립트 소수점 오류에 대해
