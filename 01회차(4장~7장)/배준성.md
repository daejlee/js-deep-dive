## 4장 변수

### 변수란? 변수의 용도

자바스크립트는 변수를 이용해서 메모리에 값을 저장하고 저장된 값을 재사용한다.

- 변수에 값을 저장 = 할당(assignment, 대입, 저장)
- 변수에 저장된 값을 읽음 = 참조(reference)

### 식별자

- 식별자(identifier) = 어떤 값을 구별해서 식별할 수 있는 고유한 이름

식별자는 값이 아니라 메모리 주소를 기억하고 있다. 메모리 주소를 통해서 메모리 공간에 저장된 값에 접근할 수 있다.
변수, 함수, 클래스 등의 이름은 모두 식별자이다.

### 변수 선언

- 변수 선언 =  변수를 생성하는 것, 메모리 공간을 확보하고 식별자에 메모리 주소를 연결하는 것이다.

변수를 사용하려면 반드시 선언이 필요하다. 변수는 var, let, const 키워드를 사용한다.

##### 스코프, 데이터 타입, 실행 컨텍스트에서 알아볼것

JS 엔진은 변수 선언을 2단계에 거쳐서 수행한다.
- 선언 단계 = 변수 이름을 등록해서 JS 엔진에 변수의 존재를 알린다.
- 초기화 단계 = 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

### 변수 선언의 실행 시점과 변수 호이스팅

변수 선언은 런타임이 아니라 그 이전 단계에서 먼저 실행된다.

- 호이스팅 = 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 특징

### 값의 할당

할당 연산자 =를 사용한다. JS는 변수 선언과 할당을 하나의 문으로 단축 표현한 경우에도 선언과 할당으로 나누어 각각 실행한다.

- 변수 선언은 런타임 이전에 실행. 변수 할당은 런타임에 실행.

변수에 값을 할당하면 이전에 저장된 값을 지우는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 새로운 값을 할당한다.

### 값의 재할당

재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다.

const로 변수를 선언하면 단 한 번만 할당할 수 있다.(재할당이 불가능하다)

재할당 되면서 더이상 필요하지 않은 메모리 공간은 가비지 콜렉터에 의해서 자동 해제된다.

##### 가비지 콜렉터의 동작 원리

### 식별자 네이밍 규칙

- 특수문자를 제외한 문자, 숫자, 인더스코터(_), 달러기호($)를 포함할 수 있다.
- 식별자는 숫자로 시작하는 것을 허용하지 않는다.
- 예약어는 식별자로 사용할 수 없다.

네이밍 컨벤션
- 변수, 함수 = 카멜 케이스
- 생성자 함수, 클래스 = 파스칼 케이스

## 5장 표현식과 문

### 값

- 값 = 식(표현식)이 평가되어 생성된 결과

모든 값은 데이터 타입을 가진다. 

### 리터럴

- 리터럴 = 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법

### 표현식

- 표현식 = 값으로 평가될 수 있는 문, 표현식이 평가되면 새로운 값을 생성하거나 기존의 값을 참조한다.

리터럴은 그 자체로 표현식이다.

### 문

- 문 = 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. 문은 여러개의 토큰으로 구성된다.

- 토큰 = 문법적인 의미를 가진다. 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.

### 세미콜론

세미콜론은 문의 종료를 나타낸다. 세미콜론 자동 삽입 기능 덕분에 생략 가능하다. 그래도 붙이는게 좋다.

### 표현식인 문과 표현식이 아닌 문

표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.

## 6장 데이터 타입

JS의 타입은 원시 타입과 객체 타입으로 구분된다.

#### 추가 내용

- Primitive type의 경우 immutable 하다는 특성을 가집니다. 실제 데이터의 값을 저장하는 타입입니다.
- Reference type의 경우 mutable 하다는 특성이 있으며 데이터를 저장한 값의 주소(참조)를 저장하는 타입입니다.

타입 구분

- Primitive type은 number, Boolean,  string, undefined, null, Symbol (ES6), BigInt (ES11)

- Reference type은 Object(객체)가 있습니다.

Object는 함수(function), 날짜(Date), 인덱스 컬렉션(Array), 키 컬렉션(Set, WeakSet, map, WeakMap)이 있습니다.

Object는 `typeof` 로 타입을 점검할 때 모두 object로 나오고, 함수의 경우에만 function으로 타입이나온다는 특이점이 있습니다. Reference type의 type을 확인하고 싶다면 `instance of` 로 인스턴스 까지 확인해주는 것이 좋습니다.

Null은 `typeof` 로 점검할 경우 object 타입으로 나오는 버그가 있습니다. 자바스크립트 버그입니다.

### 숫자 타입

JS는 하나의 숫자 타입을 가진다. 64비트 부동소수점 형식을 따른다. 즉 모든 숫자를 실수로 처리한다.

특별한 값
- Infinity = 양의 무한대
- -Infinity = 음의 무한대
- NaN = 산술 연산 불가

### 문자열 타입

JS의 문자열은 원시 타입이며 변경 불가능한 값이다.

### 템플릿 리터럴

ES6에서 도입된 새로운 문자열 표기법.
백틱(``)을 사용해 표현한다.

- 템플릿 리터럴 내에서는 줄발꿈, 공백이 모두 그대로 적용된다.
- 템플릿 리터럴 내에서는 표현식 삽입을 통해서 간단히 문자열을 삽입할 수 있다. 표현식 삽입 방식은 ${}으로 표현식을 감싸면 된다.
- 태그드 템플릿

### 불리언 타입

불리언 타입에는 true와 false만 존재한다.

### undefined 타입

undefined 타입에는 undefined만 존재한다.
JS 엔진이 변수를 초기화 할 때 사용하는 값이다.
변수 참조 시에 undefined가 반환된다면 값이 할당된 적 없는 변수이다.

### null 타입

null 타입에는 null만 존재한다.
더 이상 참조하지 않겠다는 의미가 있다. 또한 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다.

### 심벌 타입

변경 불가능한 원시 타입의 값이다.
다른 값과 중복되지 않는다. 객체의 유일한 프로퍼티 키 등을 만들기 위해서 사용된다.
Symbol 함수를 호출해 생성된다.

### BigInt 타입

BigInt는 길이의 제약 없이 정수를 다룰 수 있게 해주는 숫자형이다.
정수 리터럴 끝에 n을 붙이거나, 함수 BigInt를 호출하면 문자열이나 숫자를 가지고 BigInt 타입의 값을 만들 수 있다.
```javascript
const bigint = 1234567890123456789012345678901234567890n;

const sameBigint = BigInt("1234567890123456789012345678901234567890");

const bigintFromNumber = BigInt(10); // 10n과 동일합니다.
```

### 객체 타입

이 장의 처음 참조.

### 데이터 타입의 필요성

- 변수의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정된다.
- 값을 참조하는 경우에도 데이터 타입에 따라 한번에 읽어들일 메모리 공간의 크기를 결정한다.
- 메모리에서 읽어 들인 2진수를 메모리 타입에 따라서 해석한다.

### 동적 타이핑

JS는 동적 타입 언어이다. 할당 시점에 변수의 타입이 결정(타입 추론)되고 자유롭게 변수의 타입을 변경할 수 있다.
하지만 개발자의 의도와는 상관없이 타입이 자동으로 변환되기도 한다. 유연성은 높지만 신뢰성은 떨어진다.

## 7장 연산자

연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산등을 수행해 하나의 값을 만든다.

### 산술 연산자

수학적 계산을 수행해 새로운 값을 만든다. 산술 연산이 불가능한 경우 NaN을 리턴한다.

### 할당 연산자

피연산자 평가 결과를 변수에 저장한다.
할당문은 값으로 평가되는 표현식인 문으로 할당된 값으로 평가된다. 여러 변수에 동일한 값을 연쇄 할당할 수 있다.

### 비교 연산자

좌항과 우항의 피연산자를 비교한 다음 결과를 불리언으로 반환한다.

동등/일치 비교 연산자
- 동등(==, !=) 비교 연산자는 느슨한 비교 수행
- 일치(===, !==) 비교 연산자는 엄격한 비교 수행
동등 비교 연산자는 값 비교 시 암묵적 타입 변환을 통해 타입을 일치시킨 뒤 값만 비교한다.
일치 비교 연산자는 값은 물론 타입까지 같은지 확인한다.
일치 비교에서 NaN은 자신과 일치하지 않는 유일한 값이다. NaN인지 조사하려면 Number.isNaN을 사용한다. (동등 비교 연산자에서는??)
숫자 0의 경우 양의 0과 음의 0이 있지만 비교 결과는 항상 true이다.
위의 두 예외 사항은 Object.is를 사용하면 정확한 비교 결과를 리턴한다.

### 삼항 조건 연산자

삼항 조건 연산자는 조건식의 결과에 따라서 반환할 값을 결정한다. 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다.

### 논리 연산자

논리 연산자는 우항과 좌항의 피연산자를 논리 연산한다.

### 쉼표 연신자

쉼표 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.
(오 이런거 있는줄 몰랐네)

### 그룹 연산자

소괄호로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다. 그룹 연산자는 우선순위가 가장 높다.

### typeof 연산자

typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.
"string", "number", "boolean", "undefined", "symbot", "object", "function" 중 하나로 결과를 리턴한다.
null의 타입도 "object"로 반환하니 주의가 필요하다.
따라서 null 타입을 확인하는 경우, 일치 연산자(===)를 사용하는걸 추천한다.
선언하지 않은 식별자를 연산하는 경우 ReferenceError가 발생하지 않고 undefined를 반환한다.

### 지수 연산자

ES7에서 도입.
**로 나타내며 좌항 피연산자를 밑으로, 우항 피연산자를 지수로 사용하여 거듭 제곱한다.
음수를 밑으로 사용하려면 괄호로 묶어야한다.
(지수인 경우에는??)

### 그 외의 연산자

##### 옵셔널 체이닝 => 9.4.2절

### 연산자의 부수 효과

대부분의 연산자는 다른 코드에 영향을 주지 않는다. 하지만 할당, 증감, delete 연산자는 부수 효과가 있다.

### 연산자 우선순위

[연산자 우선 순위](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Operator_precedence)

### 연산자 결합 순서

표 삽입.
