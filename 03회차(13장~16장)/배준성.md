## 13장 스코프

### 스코프란?

- 스코프 = 식별자를 참조할 수 있는 유효범위.

스코프를 통해서 식별자의 이름이 같아도 유일한 식별자로 구분할 수 있다.

##### 참조 키워드

- 렉시컬 환경
- 실행 컨텍스트

### 스코프의 종류

- 전역 스코프 = 코드의 가장 바깥 영역 스코프, 어디서든지 참조할 수 있다.
- 지역 스코프 = 함수 몸체 내부 스코프, 자신과 하위 지역 스코프에서 유효하다.

### 스코프 체인

- 스코프 체인 = 스코프가 계층적으로 연결된 것. JS 엔진은 변수를 참조할 경우 현재 스코프에서 상위 스코프 방향으로 이동하면서 변수를 검색한다.

### 함수 레벨 스코프

지역 스코프는 블록이 아닌 함수에 의해서만 생성된다.

var 키워드로 선언된 변수는 함수 레벨 스코프를 가진다. 함수 레벨 스코프는 오직 함수 코드 볼록만 지역 스코프로 인정한다.

let, const는 블록 레벨 스코프를 지원한다. 블록 레벨 스코프는 함수 뿐만 아니라 모든 코드 블록이 지역 스코프를 만든다.

### 렉시컬 스코프

렉시컬 스코프(정적 스코프)는 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다.

```javascript
  vat x = 1;

  function foo() {
    var x = 10;
    bar();
  }

  function bar() {
    console.log(x);
  }

  foo(); // 1
  bar(); // 1
```

## 14장 전역 변수의 문제점

### 변수의 생명주기

지역 변수의 생명 주기는 함수의 생명주기와 일치한다.
함수 내부에서 선언된 변수들은 함수가 호출되면 함수 내부에 선언된 변수들이 JS엔진에 의해 먼저 실행된다.
즉 호이스팅은 스코프 단위로 동작한다. 호이스팅은 변수 선언이 스코프의 선두로 끌어올려진 것 처럼 동작하는 특징이다.

var로 선언된 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다. (호이스팅)

### 전역 변수의 문제점

변수의 유효 범위가 크면 클수록 가독성이 떨어지고 의도치 않게 상태가 변경될 수 있다.
전역 변수는 메모리 리소스를 오랜 기간동안 소비하게 된다.
또한 전역 변수는 스코프 체인의 끝에 존재하기 때문에 검색 속도가 가장 느리다.
마지막으로 파일이 분리되어 있어도 전역 스코프를 공유하기 때문에 예상치 못한 결과를 불러올 수 있다.

### 전역 변수의 사용을 억제하는 방법

- ES6 모듈 = ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.

## 15장 let, const 키원드와 블록 레벨 스코프

1. 중복 선언(재선언)

   var - 중복 선언 가능

   let, const - 중복 선언 불가능, Syntax Ey7rror

2. 재할당

   var, let - 재할당 가능

   const - 재할당 불가능

3. 스코프

   var - 함수 스코프를 가짐

   let, const - 블록 스코프를 가짐

4. 호이스팅

   var - 호이스팅 + undefined로 초기화

   let, const - 호이스팅 + 초기화 x, TDZ에서 호출 -> Refference Error 출력

#### const 객체

const 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있다. const는 재할당을 금지할 뿐 불변을 의미하지는 않는다.

## 16장 프로퍼티 어트리뷰트

### 내부 슬롯과 내부 메서드

내부 슬롯과 내부 메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드이다.
개발자가 직접 접근할 수 있도록 공개된 객체의 프로퍼티는 아니다. 일부의 경우 간접적으로 접근할 수 있는 수단은 있다.

### 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

JS엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.
프로퍼티 상태는 프로피터의 값, 값 갱신 가능 여부, 열거 가능 여부, 재정의 가능 여부를 말한다.

### 데이터 프로퍼티와 접근자 프로퍼티

프로퍼티는 데이터와 접근자 프로퍼티로 구분할 수 있다.

- 데이터 프로퍼티 = 키와 값으로 구성된 일반적인 프로퍼티.
- 접근자 프로퍼티 = 자체적으로 값을 갖지 않고 다른 데티어 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티.

##### 데이터 프로퍼티 어트리뷰트

- value
- writable
- enumerable
- configurable

##### 접근자 프로퍼티

- get (getter 역할)
- set (setter 역할)
- enumerable
- configurable

### 프로퍼티 정의

Object.defineProperty 메서드를 사용하면 프로퍼티의 어트리뷰트를 정의할 수 있다. 인수로는 객체의 참조와 데이터 프로퍼티의 키인 문자열, 프로퍼티 디스크립터 객체를 전달한다.
프로퍼티 누락 시 undefined, false가 기본값이다.

### 객체 변경 방지

| 구분           | 메서드                    | 프로퍼티 추가 | 프로퍼티 삭제 | 프로퍼티 값 읽기 | 프로퍼티 값 쓰기 | 프로퍼티 어트리뷰트 재정의 |
| -------------- | ------------------------- | ------------- | ------------- | ---------------- | ---------------- | -------------------------- |
| 객체 확장 금지 | Object.prevent Extensions | X             | O             | O                | O                | O                          |
| 객체 밀봉      | Object.seal               | X             | X             | O                | O                | O                          |
| 객체 동결      | Object.freeze             | X             | X             | O                | X                | X                          |

#### 불변 객체

위의 방지 메서드들은 얕은 변경 방지로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지 영향을 주지는 못한다.
객체의 중첩 객체까지 동결하여 변경이 불가능한 읽기 전용 불변 객체를 구현하려면 객체를 값으로 갖는 모든 프로퍼티에 대해서 재귀적으로 Object.freeze 메서드를 호출해야한다.
