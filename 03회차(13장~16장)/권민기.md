# 13, 14, 15, 16

# 13 스코프

## 13.1 스코프란?

: **`식별자가 유효한 범위`**

**식별자 결정**

: 자바스크립트 엔진은 이름이 같은 두 변수 중 어떤 변수를 참조할 지 결정

→ 스코프는 자바스크립트 엔진이 식별자를 검색할 때 사용되는 규칙

<aside>
💡 스코프라는 개념이 없다면 프로그램 전체에서 유일한 이름을 한번밖에 사용할 수 없다.

식별자는 유일해야하지만, 다른 스코프에는 같은 이름의 식별자를 사용할 수 있다.

스코프는 네임스페이스다.

</aside>

## 13.2 스코프의 종류

| 구분 | 설명 | 스코프 | 변수 |
| --- | --- | --- | --- |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역 | 함수 몸체의 내부 | 지역 스코프 | 지역 변수 |
- 전역변수
    - 어디에서나 참조 할 수 있다.
- 지역 변수
    - 자신의 지역 스코프와 하위 지역 스코프에서만 유효하다.

## 13.3 스코프 체인

- 함수의 중첩 : 함수 몸체 내부에 함수가 정의 된 것.
- 중첩 함수 : 함수 몸체 내부에서 정의한 함수
- 외부 함수 : 중첩 함수를 포함하는 함수

변수를 참조 할 때, 자바스크립트 엔진은 스코프 체인을 통해 **변수를 참조하는 코드의 스코프에서 시작**하여 **`상위 스코프 방향`**으로 이동하며 선언된 변수를 검색한다.

## 13.4 함수 레벨 스코프

**블록 레벨 스코프**

C, Java를 비롯한 언어들은 함수 몸체만이 아니라 **모든 코드 블록**이 지역 스코프를 만든다.

**함수 레벨 스코프**

**`var`**키워드로 선언된 변수는 오로지 **`함수의 코드 블록`**만을 지역 스코프로 인정한다.

## 13.5 렉시컬 스코프

**동적 스코프 -** Emacs Lisp, APL

함수를 어디서 **`호출`** 했는지에 따라 함수의 상위 스코프를 결정한다.

**렉시컬 스코프 - 자바스크립트**, C, Java,,

함수를 어디서 **`정의`** 했는지에 따라 함수의 상위 스코프를 결정한다.

# 14.전역 변수의 문제점

## 14.1 변수의 생명주기

### 14.1.1 지역 변수의 생명 주기

지역변수의 생명주기는 **`함수의 생명주기와 일치`**

변수는 스코프의 메모리가 해제 될 때 까지 유효하다.

누군가 메모리공간을 참조하고있으면 해제되지 않고 확보된 상태로 남아있다.

호이스팅은 **`스코프를 단위`**로 동작한다.

= 변수 선언이 **`스코프의 선두`**로 끌어올려 진 것처럼 동작

### 14.1.2 전역 변수의 생명 주기

전역 변수는 코드가 로드되자마자 곧바로 해석되고 실행된다.

**`var`**로 선언한 지역변수는 전역 객체의 프로퍼티가 된다. (`전역 객체의 생명주기와 일치`한다.)

브라우저 환경에서 전역 객체는 **`window`**이다. 브라우저 환경에서 var로 선언한 전역변수는 **window의 프로퍼티**가 된다.

## 14.2 전역 변수의 문제점

- 암묵적 결합
    - 모든 코드가 전역변수를 참조하고 변경할 수 있음을 허용함
    - 의도치 않게 상태가 변경될 수 있는 위험성이 높음
- 긴 생명 주기
    - 메모리 리소스를 오랜 기간 소비함
    - var은 중복 선언을 허용하므로 의도치않은 재할당이 이루어 질 위험이 있음
- 스코프 체인 상에서 종점에 존재
    - 전역 변수의 검색 속도가 가장 느리다.
- 네임스페이스 오염
    - 자바 스크립트는 파일이 분리되어있어도 전역 스코프를 공유함
    - 다른 파일 내 동일한 이름으로 명명된 전역변수나 전역함수가 같은 스코프 내 존재할 위험

## 14.3 전역 변수의 사용을 억제하는 방법

전역 변수를 반드시 사용해야 할 이유가 없다면 지역변수를 사용해야한다.

**`변수의 스코프는 좁을수록 좋다.`**

### 14.3.1 즉시 실행 함수

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 지역 변수가 된다.

### 14.3.2 네임스페이스 객체

전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고싶은 변수를 프로퍼티로 추가하는 방법.

→ 그닥,,

### 14.3.3 모듈 패턴

`클로저`와 `즉시 실행 함수 표현식`을 이용하여 구현.

정보 은닉을 구현하기 위해 사용

```jsx
const myModule = (function() {
  // 프라이빗 변수와 메서드
  let count = 0;
  
  function increment() {
    count++;
  }
  
  function decrement() {
    count--;
  }
  
  // 퍼블릭 API
  return {
    getCount: function() {
      return count;
    },
    
    increase: function() {
      increment();
    },
    
    decrease: function() {
      decrement();
    }
  };
})();

console.log(myModule.getCount()); // -> 0
myModule.increase();
console.log(myModule.getCount()); // -> 1
myModule.decrease();
console.log(myModule.getCount()); // -> 0
```

### 14.3.4 ES6 모듈

ES6모듈을 사용하면 더는 전역변수를 사용할 수 없다.

독자적인 모듈 스코프를 제공한다.

= 모듈 내에서 var로 선언한 변수는 전역변수가 아니며 window 객체의 프로퍼티도 아니다.

다른 변수나 함수를 **`import`**, 다른 곳에서 사용할 수 있도록 **`export`**

# 15 let, const 키워드와 블록 레벨 스코프

## 15.1 var 키워드로 선언한 변수의 문제점

### 15.1.1 변수 중복 선언 허용

중복 선언이 되면 재할당이 된다.

### 15.1.2 함수 레벨 스코프

함수 외부에서 선언한 변수는 코드 블록 내에서 재선언해도 전역 변수의 값이 변경된다.

### 15.1.3 변수 호이스팅

호이스팅에 의해 선언문 이전에 참조할 수 있지만, 언제나 undefined가 반환된다.

## 15.2 let 키워드 (ES6)

### 15.2.1 변수 중복 선언 금지

let, const는 같은 스코프 내에서는 중복 선언이 허용되지 않는다. - SyntaxError

### 15.2.2 블록 레벨 스코프

var - 함수 레벨 스코프

let - 블록 레벨 스코프 (모든 코드블록을 지역 스코프로 따른다)

### 15.2.3 변수 호이스팅

`변수 호이스팅이 **발생하지 않는 것처럼** 동작한다.`

선언문 이전에 참조하면 **참조 에러(ReferenceError)**가 발생한다.

let 키워드로 선언한 변수는 **선언 단계와 초기화 단계가 분리**되어 진행된다. 그러나 let 변수는 `초기화 시작 시점`까지 변수를 **참조할 수 없다**. 이를 `일시적 사각지대`라고 부른다.

(const, class 도 동일)

### 15.2.4 전역 객체와 let

let으로 선언한 전역변수는 전역 객체 window의 프로퍼티가 아니다.

별도의 전역 스코프에 저장된다.

## 15.3 const 키워드 (ES6)

상수(constant)를 선언하기 위해 사용된다.

### 15.3.1 선언과 초기화

const 변수는 반드시 **`선언과 동시에 초기화`** 해야한다. - SyntaxError

let과 동일하게 호이스팅이 발생하지 않는 것 처럼 동작한다.

### 15.3.2 재할당 금지

재할당이 금지된다. - TypeError

### 15.3.3 상수

상수 : 재할당이 금지된 변수

const 변수에 **`원시값`**을 할당한 경우 **`변경될 수 없다.`**

일반적으로 상수는 스네이크 케이스로 작성된다.

```jsx
const TAX_RATE = 0.1;
```

### 15.3.4 const 키워드와 객체

const 변수에 **`객체`**를 할당한 경우 값을 **`변경 할 수 있다.`** (객체는 변경 가능한 값이다.)

<aside>
💡 const 키워드는 재할당을 금지할 뿐, **불변**을 의미하지 않는다.

</aside>

## 15.4 var vs let vs const

기본적으로 const를 사용하고 재할당이 필요한 경우에만 한정하여 let 사용하기를 권장

# 16 프로퍼티 어트리뷰트

## 16.1 내부 슬롯과 내부 메서드

ECMAScript 사양에서 객체의 동작을 정의하기 위해 사용되는 개념

### 내부 슬롯 (Internal Slot)

내부 슬롯은 **객체에 연결된 내부 상태**를 나타내며, 대괄호로 둘러싸인 형식으로 표기

자바스크립트 엔진 내부에서만 접근 가능하며, 일반적인 자바스크립트 코드에서는 직접적으로 접근 불가능.. 하지만 **Prototype**의 경우 `__Protot__`를 통해 간접적으로 접근 가능

- `[[Prototype]]`: 객체의 프로토타입, 프로토타입 체인을 통해 상속을 구현하는 데 사용
- `[[Scopes]]`: 함수가 렉시컬 환경을 참조하는 데 사용

### 내부 메서드 (Internal Method)

내부 메서드는 **객체가 특정 작업을 수행**할 때 호출

표준 메서드와는 달리 자바스크립트 코드에서 직접 호출 불가능 (객체에 대한 특정 연산을 수행할 때 자동으로 호출)

- `[[Get]]`: 객체의 속성 값을 가져옴
- `[[Set]]`: 객체의 속성 값을 설정함
- `[[Call]]`: 함수 객체가 호출될 때 실행
- `[[Construct]]`: 함수 객체가 `new` 연산자를 통해 호출될 때 실행

## 16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

자바스크립트 엔진은 프로퍼티를 생성 할 때, **`프로퍼티의 상태`**를 나타내는 **`프로퍼티 어트리뷰트`**를 기본값으로 **자동정의**한다.

### 프로퍼티 어트리뷰트

프로퍼티의 내부 상태값

- `[[Value]]` : 속성의 값
- `[[Writable]]`: 속성의 값이 변경가능한 상태인지 (Boolean)
- `[Enumerable]]`: 속성이 열거 가능한 상태인지 (Boolean)
- `[[Configurable]]`: 속성의 어트리뷰트를 변경할 수 있는 상태인지 (Boolean)

### 프로퍼티 디스크립터 객체

프로퍼티 디스크립터 객체는 프로퍼티 어트리뷰트를 **`설명하는 객체`** 

- `Object.getOwnPropertyDescriptor`
    - 객체의 특정 속성에 대한 프로퍼티 디스크립터 객체를 반환
- `Object.defineProperty`
    - 객체의 특정 속성에 대한 프로퍼티 디스크립터 객체를 정의

## 16.3 데이터 프로퍼티와 접근자 프로퍼티

### 16.3.1 데이터 프로퍼티

**`키와 값`**으로 구성된 프로퍼티

- `[[Value]]` : 속성의 값
- `[[Writable]]`: 속성의 값이 변경가능한 상태인지 (Boolean)
- `[Enumerable]]`: 속성이 열거 가능한 상태인지 (Boolean)
- `[[Configurable]]`: 속성의 어트리뷰트를 변경할 수 있는 상태인지 (Boolean)

### 16.3.2 접근자 프로퍼티

자체적으로 값을 갖지 않고 **`접근자 함수`**로 구성된 프로퍼티

- `[[Get]]`: 객체의 속성 값을 가져옴
- `[[Set]]`: 객체의 속성 값을 설정함
- `[Enumerable]]`: 속성이 열거 가능한 상태인지 (Boolean)
- `[[Configurable]]`: 속성의 어트리뷰트를 변경할 수 있는 상태인지 (Boolean)

### 프로토타입 (protoType)

프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체이다. 프로토타입은 하위 객체에게 메서드를 상속한다.

### 프로토타입 체인 (Prototype Chain)

**프로토타입이 단방향 링크드 리스트 형태로 연결되어 있는 상속 구조**

객체의 프로퍼티나 메서드에 접근을 하려 할 때, 해당 프로퍼티가 없다면 프로토타입 체인을 따라 차례대로 검색한다.

ex.

```jsx
function Animal() {}
Animal.prototype.move = function() {
  console.log('Moving...');
};

function Bird() {}
Bird.prototype = Object.create(Animal.prototype);
Bird.prototype.fly = function() {
  console.log('Flying...');
};

const sparrow = new Bird();
sparrow.move(); // "Moving..."
sparrow.fly(); // "Flying..."
```

### 접근자 프로퍼티와 데이터 프로퍼티의 구별

- **`__proto__`**는 객체의 프로토타입을 나타내는 **접근자 프로퍼티**
    
    ```jsx
    Object.getOwnPropertyDescriptor(Object.prototype, ' __proto__');
    // {get: f, set: f, enumerable: false, configurable: true}
    
    ```
    
- **`prototype`**은 해당 함수가 생성자로 사용될 때 생성된 객체가 상속받는 프로토타입 객체를 가리키는 **데이터 프로퍼티 (**함수 객체만이 가지는 속성)
    
    ```jsx
    Object.getOwnPropertyDescriptor(function() {}, 'prototype');
    // {value: {... }, writable: true, enumerable: false, configurable: false}
    ```
    

## 16.4 프로퍼티 정의

새로운 프로퍼티를 **추가**하며 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존의 프로퍼티의 프로퍼티 어트리뷰트를 **재정의** 하는 것.

**`Object.defineproperty`** 이용

```jsx
// 데이터 프로퍼티 정의
Object defineProperty(person, 'firstName', {
	value: 'Ungmo', 
	writable: true, 
	enumerable:true, 
	configurable: true,
});
```

+) 일부 프로퍼티 생략 가능. 생략 시 기본값이 적용됨 (값은 undefined, Boolean값은 false)

## 16.5 객체 변경 방지

객체는 변경 가능한 값 → 재할당 없이 직접 변경 가능

프로퍼티 추가, 삭제, 갱신 가능.

**`Object.defineproperty`** 또는 **`0bject.defineproperties`** 을 이용하여 프로퍼티 어트리뷰트 재정의가 가능

자바스크립트는 객체의 변경을 방지하는 메서드를 제공

<img width="552" alt="image" src="https://github.com/user-attachments/assets/57cfa99e-eafd-46dc-8d51-ec32acba4b27">


### 16.5.1 객체 확장 금지

**`Object.preventExtensions`**

확장이 금지된 객체는 프로퍼티 추가가 금지 됨

**`Object. isExtensible`**

확장 가능한 객체인지 여부확인 가능

### 16.5.2 객체 밀봉

**`Object.seal`**

밀봉된 객체는 읽기와 쓰기만 가능함. (프로퍼티 추가, 삭제, 재정의 금지)

**`Object.isSeal`**

밀봉된 객체인지 여부 확인 가능

### 16.5.3 객체 동결

**`Object.freeze`**

동결된 객체는 읽기만 가능하다. (프로퍼티 추가, 삭제, 재정의, 쓰기 금지)

**`Object.isFreeze`**

동결된 객체인지 여부 확인 가능

### 16.5.4 불변 객체

`Object.freeze`를 사용하여도 중첩 객체까지 동결 할 수 없다.

→ 얕은 객체 동결. 직속 프로퍼티만 동결함

중첩 객체까지 동결하려면 모든 프로퍼티에대해 **재귀적**으로 freeze를 호출해야함.

+) 불변 객체를 쉽게 만들고 관리하기 위한 라이브러리 소개

### Immer 라이브러리

불변성을 유지하면서 객체 업데이트 가능

Immer는 원본 상태를 변경하지 않으며, 모든 변경 사항을 반영한 **새로운 상태를 반환**

(원본을 유지한 채, 초안(draft)을 작성하여 새로운 불변 객체를 생성)

```jsx
import produce from 'immer';

const baseState = [
  { todo: "Learn JavaScript", done: true },
  { todo: "Learn immer", done: false }
];

const nextState = produce(baseState, draftState => {
  draftState.push({ todo: "Master immer", done: false });
  draftState[1].done = true;
});

console.log(baseState); // 원본 배열은 변경되지 않음
console.log(nextState); // 새로운 배열에 변경 사항 반영
```

produce 함수

```jsx
const nextState = produce(baseState, draftState => {
  // 초안 상태를 직접 변경
  draftState[0].done = false;
  draftState.push({ todo: "Try immer", done: false });
});
```

ex.

```jsx
const state = { a: 1, b: { c: 2 } };

const nextState = produce(state, draft => {
  draft.b.c = 3;
});

console.log(state); // { a: 1, b: { c: 2 } }
console.log(nextState); // { a: 1, b: { c: 3 } }

```
