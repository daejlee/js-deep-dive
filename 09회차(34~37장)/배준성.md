614 ~ 660

# 34장 이터러블

## 이터레이터

- 이터러블의 Symbol.iterator 메서드를 호출하면 이터레이터 반환.
- 이터레이터는 next 메서드를 갖는다. next 메서드를 호출하면 한 단계씩 순회하며 순회 결과를 나타내는 이터레이터 리절트 객체를 반환.
- 마지막 객체는 value는 undefiend, done을 true로 갖는 객체이다.

## for ... of

- for ... of 문을 이용하여 순회 가능.
- for (변수선언문 of 이터러블) {...}

## 유사 배열 객체

- 배열처럼 인덱스로 접근 가능.
- length 프로퍼티를 가짐. for문으로 순회 가능.
- 이터러블이 아닌 일반 객체이다. Symbol.iterator 메서드가 없어서 for...of로 순회 불가능.
- 단, arguments, NodeList, HTMLCollection은 유사 배열 객체이면서 이터러블이다. ES6에서 Symbol.iterator을 구현하였기 때문이다. 배열도 같은 이유로 ES6에서 이터러블이 되었다.
- 이터러블이 아닌 유사 배열 객체는 Array.from을 이용해서 배열로 변환 가능.

## 이터레이션 프로토콜의 필요성

- 데이터 소비자와 공급자를 연결하는 인터페이스 역할을 한다. 이터레이션 프로토콜만 만족하면 쉽게 순회 가능하기 때문에 소비자나 공급자 모두 쉽게 구현 가능하다.

# 35장 스프레드 문법

- 스프레드 문법 ...은 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다.
- 이터러블만 스프레드 문법을 사용할 수 있다.
- 스프레드 문법의 결과는 값이 아니가 때문에 변수에 할당할 수 없다.
- Rest문법과는 정반대로 동작한다.

# 36장 디스트럭처링 할당

- 디스트럭처링 할당 (구조 분해 할당)은 구조화된 배열과 같은 이터러블/객체를 비구조화하여 1개 이상의 변수에 개별적으로 할당하는 것이다.

## 배열 디스트럭처링 할당

- 배열 디스트럭처링 할당의 대상은 이터러블이어야 한다.
- 할당 기준은 배열의 인덱스이다. 즉, 순서대로 할당된다. 변수 개수와 이터러블의 요소 개수가 반드시 일치할 필요는 없다.
- 변수에 기본값을 할당 가능. (e.g. const [a, b, c = 3] = [1, 2])
- 변수에 Rest 파라미터와 유사하게 Rest 요소를 사용할 수 있다. (e.g. const [x, ...y] = [1, 2, 3] // x = 1, y = [2, 3])

## 객체 디스트럭처링 할당

- 객체 디스트럭처링 할당의 대상은 객체이어야 한다.
- 할당 기준은 프로퍼티 키이다. 순서는 의미 없으며 선언된 변수 이름과 프로퍼티 키가 일치하면 할당.
- 변수에 기본값 설정 가능.
- 배열 요소가 객체인 경우 배열 디스트럭처링 할당과 객체 디스트럭처링 할당을 혼용 가능하다.
- Rest 요소와 유사하게 Rest 프로퍼티 사용 가능.

# 37장 Set과 Map

## Set

- 중복되지 않는 유일한 값들의 집합.
- 요소 순서에 의미가 없음.
- 인덱스로 요소에 접근 불가.
- Set 객체는 이터러블이다. (for...of, 스프레드, 디스트럭처링 가능)
- 집합 연산을 할 수 있다는 것이 특징.

## Map

- 키와 값의 쌍으로 이루어진 컬렉션.
- 객체를 포함한 모든 값을 키로 사용 가능.
- Map은 이터러블이다.
- 요소 개수 확인은 map.size를 사용한다.
- Map 생성자를 통해서 생성. 생성자는 이터러블을 인수로 전달받아 Map 객체를 생성. 인수는 키와 값으로 이루어진 요소로 구성되어야함.
- 중복된 키를 가지면 값이 덮어써진다. (중복 불가)
- get하는 경우 인자로 받은 키를 갖는 요소가 없으면 undefined를 리턴.
